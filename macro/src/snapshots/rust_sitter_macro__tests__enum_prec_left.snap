---
source: macro/src/lib.rs
expression: "rustfmt_code(&expand_grammar(parse_quote! {\n                            mod ffi\n                            {\n                                #[rust_sitter :: language] pub enum Expression\n                                {\n                                    Number(#[rust_sitter ::\n                                    leaf(pattern = r\"\\d+\", transform = | v : & str | v.parse ::\n                                    < i32 > ().unwrap())] i32), #[rust_sitter :: prec_left(1)]\n                                    Sub(Box < Expression >,\n                                    #[rust_sitter :: leaf(text = \"-\", transform = | v | ())] (),\n                                    Box < Expression >),\n                                }\n                            }\n                        }).to_token_stream().to_string())"
---
mod ffi {
    pub enum Expression {
        Number(i32),
        Sub(Box<Expression>, (), Box<Expression>),
    }
    impl rust_sitter::Extract for Expression {
        #[allow(non_snake_case)]
        fn extract(node: tree_sitter::Node, source: &[u8]) -> Self {
            #[allow(non_snake_case)]
            fn extract_Expression_Number_0(node: tree_sitter::Node, source: &[u8]) -> i32 {
                (|v: &str| v.parse::<i32>().unwrap())(node.utf8_text(source).unwrap())
            }
            #[allow(non_snake_case)]
            fn extract_Expression_Number(node: tree_sitter::Node, source: &[u8]) -> Expression {
                Expression::Number(extract_Expression_Number_0(
                    node.child_by_field_name("0").unwrap(),
                    source,
                ))
            }
            #[allow(non_snake_case)]
            fn extract_Expression_Sub_0(node: tree_sitter::Node, source: &[u8]) -> Box<Expression> {
                Box::new(Expression::extract(node, source))
            }
            #[allow(non_snake_case)]
            fn extract_Expression_Sub_1(node: tree_sitter::Node, source: &[u8]) -> () {
                (|v| ())(node.utf8_text(source).unwrap())
            }
            #[allow(non_snake_case)]
            fn extract_Expression_Sub_2(node: tree_sitter::Node, source: &[u8]) -> Box<Expression> {
                Box::new(Expression::extract(node, source))
            }
            #[allow(non_snake_case)]
            fn extract_Expression_Sub(node: tree_sitter::Node, source: &[u8]) -> Expression {
                Expression::Sub(
                    extract_Expression_Sub_0(node.child_by_field_name("0").unwrap(), source),
                    extract_Expression_Sub_1(node.child_by_field_name("1").unwrap(), source),
                    extract_Expression_Sub_2(node.child_by_field_name("2").unwrap(), source),
                )
            }
            match node.child(0).unwrap().kind() {
                "Expression_Number" => extract_Expression_Number(node.child(0).unwrap(), source),
                "Expression_Sub" => extract_Expression_Sub(node.child(0).unwrap(), source),
                _ => panic!(),
            }
        }
    }
    extern "C" {
        fn tree_sitter_grammar() -> tree_sitter::Language;
    }
    fn language() -> tree_sitter::Language {
        unsafe { tree_sitter_grammar() }
    }
    pub fn parse(
        input: &str,
    ) -> core::result::Result<Expression, Vec<rust_sitter::errors::ParseError>> {
        let mut parser = tree_sitter::Parser::new();
        parser.set_language(language()).unwrap();
        let tree = parser.parse(input, None).unwrap();
        let root_node = tree.root_node();
        if root_node.has_error() {
            let mut errors = vec![];
            rust_sitter::errors::collect_parsing_errors(&root_node, input.as_bytes(), &mut errors);
            Err(errors)
        } else {
            use rust_sitter::Extract;
            Ok(Expression::extract(
                root_node.child(0).unwrap(),
                input.as_bytes(),
            ))
        }
    }
}

